# 链路延时数据收集功能开发规范

## 1. 概述

本文档定义了链路延时数据收集功能的前后端开发规范，确保前后端API接口的一致性、数据格式的统一性以及代码质量。

## 2. API接口规范

### 2.1 接口命名规范

- **RESTful风格**：使用标准的HTTP方法（GET、POST、PUT、DELETE）
- **路径命名**：使用kebab-case（短横线分隔）
- **统一前缀**：所有链路相关接口使用 `/v1/chain/collection` 前缀

### 2.2 接口列表

#### 2.2.1 数据收集控制接口

| 方法 | 路径 | 说明 | 参数 |
|------|------|------|------|
| POST | `/v1/chain/collection/start/{taskId}/{chainId}` | 启动数据收集 | taskId, chainId |
| POST | `/v1/chain/collection/stop/{taskId}/{chainId}` | 停止数据收集 | taskId, chainId |
| GET | `/v1/chain/collection/status/{taskId}/{chainId}` | 获取收集状态 | taskId, chainId |

#### 2.2.2 数据查询接口

| 方法 | 路径 | 说明 | 参数 |
|------|------|------|------|
| GET | `/v1/chain/collection/data` | 查询延时数据 | chainId, nodeId, taskId, startTime, endTime, page, count |
| GET | `/v1/chain/collection/latency/{requestId}` | 计算链路总延时 | requestId |
| POST | `/v1/chain/collection/correlate` | 关联请求数据 | requestId |

#### 2.2.3 统计分析接口

| 方法 | 路径 | 说明 | 参数 |
|------|------|------|------|
| GET | `/v1/chain/collection/chain-stats/{chainId}` | 获取链路性能统计 | chainId, startTime, endTime |
| GET | `/v1/chain/collection/node-stats/{nodeId}` | 获取节点性能统计 | nodeId, startTime, endTime |
| GET | `/v1/chain/collection/latency-trend` | 获取延时趋势数据 | chainId, startTime, endTime, granularity |
| GET | `/v1/chain/collection/throughput` | 获取吞吐量数据 | chainId, startTime, endTime, granularity |
| GET | `/v1/chain/collection/node-performance` | 获取节点性能对比 | chainId, startTime, endTime |
| GET | `/v1/chain/collection/latency-distribution` | 获取延时分布数据 | chainId, startTime, endTime |

#### 2.2.4 数据管理接口

| 方法 | 路径 | 说明 | 参数 |
|------|------|------|------|
| DELETE | `/v1/chain/collection/cleanup` | 清理过期数据 | beforeTime |

### 2.3 请求参数规范

#### 2.3.1 时间参数格式

- **前端传递格式**：`YYYY-MM-DD HH:mm:ss` 或 ISO 8601格式（`YYYY-MM-DDTHH:mm:ss`）
- **后端接收格式**：支持多种格式自动解析
- **数据库存储格式**：`DATETIME` 类型

#### 2.3.2 分页参数

- `page`: 页码，从0开始
- `count`: 每页数量，默认20

#### 2.3.3 时间粒度参数（granularity）

- `minute`: 1分钟
- `5minute`: 5分钟
- `hour`: 1小时

### 2.4 响应数据格式规范

#### 2.4.1 统一响应结构

```json
{
  "code": 0,
  "message": "success",
  "data": { ... }
}
```

#### 2.4.2 分页响应结构

```json
{
  "total": 100,
  "items": [...],
  "page": 0,
  "count": 20
}
```

#### 2.4.3 链路性能统计响应格式

```json
{
  "chainId": 1,
  "chainName": "订单处理链路",
  "totalRequests": 1000,
  "successfulRequests": 950,
  "failedRequests": 50,
  "avgChainLatency": 125.5,
  "maxChainLatency": 500,
  "minChainLatency": 10,
  "p95ChainLatency": 250.0,
  "p99ChainLatency": 400.0,
  "successRate": 95.0,
  "nodeStats": {
    "1": {
      "nodeId": 1,
      "nodeName": "网关",
      "totalRequests": 1000,
      "avgLatency": 50.0,
      "p95Latency": 100.0
    }
  },
  "bottleneckNodes": ["网关", "数据库"]
}
```

**注意**：为了与前端保持一致，后端返回的字段名应该同时支持：
- `avgChainLatency` / `avgLatency`（前端兼容）
- `totalRequests` / `totalCount`（前端兼容）

#### 2.4.4 延时趋势数据响应格式

```json
[
  {
    "time": "2024-01-01 10:00:00",
    "avgLatency": 100.5,
    "p95Latency": 200.0,
    "p99Latency": 300.0,
    "count": 100
  },
  {
    "time": "2024-01-01 10:05:00",
    "avgLatency": 105.2,
    "p95Latency": 210.0,
    "p99Latency": 310.0,
    "count": 120
  }
]
```

#### 2.4.5 吞吐量数据响应格式

```json
[
  {
    "time": "2024-01-01 10:00:00",
    "count": 100,
    "qps": 20.0
  },
  {
    "time": "2024-01-01 10:05:00",
    "count": 120,
    "qps": 24.0
  }
]
```

#### 2.4.6 节点性能对比响应格式

```json
[
  {
    "nodeId": 1,
    "nodeName": "网关",
    "avgLatency": 50.0,
    "p95Latency": 100.0,
    "p99Latency": 150.0,
    "maxLatency": 200,
    "errorRate": 1.5
  },
  {
    "nodeId": 2,
    "nodeName": "订单服务",
    "avgLatency": 80.0,
    "p95Latency": 150.0,
    "p99Latency": 200.0,
    "maxLatency": 300,
    "errorRate": 2.0
  }
]
```

#### 2.4.7 延时分布数据响应格式

```json
[
  {
    "name": "0-50ms",
    "value": 500
  },
  {
    "name": "50-100ms",
    "value": 300
  },
  {
    "name": "100-200ms",
    "value": 150
  },
  {
    "name": "200-500ms",
    "value": 40
  },
  {
    "name": ">500ms",
    "value": 10
  }
]
```

## 3. 数据模型规范

### 3.1 数据库字段命名

- 使用 `snake_case` 命名
- 时间字段统一使用 `_time` 后缀
- 布尔值字段使用 `is_` 前缀或 `success` 等语义化命名

### 3.2 Java实体类规范

- 使用 `camelCase` 命名
- 时间字段使用 `LocalDateTime` 类型
- 使用 Lombok 注解简化代码

### 3.3 前端数据模型规范

- 使用 `camelCase` 命名
- 时间字段统一转换为字符串格式
- 使用 TypeScript 类型定义（如适用）

## 4. 错误处理规范

### 4.1 HTTP状态码

- `200`: 成功
- `400`: 请求参数错误
- `401`: 未授权
- `403`: 无权限
- `404`: 资源不存在
- `500`: 服务器内部错误

### 4.2 错误响应格式

```json
{
  "code": 40001,
  "message": "参数错误：链路ID不能为空",
  "data": null
}
```

## 5. 前后端交互规范

### 5.1 时间格式转换

**前端发送**：
- 日期选择器：`YYYY-MM-DD HH:mm:ss`
- ISO格式：`YYYY-MM-DDTHH:mm:ss`

**后端接收**：
- 自动解析多种格式
- 统一转换为 `LocalDateTime`

**后端返回**：
- 统一格式化为 `YYYY-MM-DD HH:mm:ss`
- 或使用 ISO 8601 格式

### 5.2 字段映射规则

为了兼容前端已有的代码，后端需要同时支持新旧字段名：

| 后端字段 | 前端字段（兼容） | 说明 |
|---------|----------------|------|
| `avgChainLatency` | `avgLatency` | 平均延时 |
| `totalRequests` | `totalCount` | 总请求数 |
| `failedRequests` | `errorCount` | 失败请求数 |

### 5.3 空值处理

- 数字类型：返回 `0` 而不是 `null`
- 字符串类型：返回空字符串 `""` 而不是 `null`
- 数组类型：返回空数组 `[]` 而不是 `null`

## 6. 代码质量规范

### 6.1 后端代码规范

- 所有Controller方法必须添加 `@ApiOperation` 注解
- 所有Service方法必须添加日志记录
- 异常必须被捕获并记录日志
- 数据库操作必须使用事务（如需要）

### 6.2 前端代码规范

- API调用必须使用统一的axios封装
- 错误必须被捕获并提示用户
- 加载状态必须正确显示
- 图表组件必须正确销毁

### 6.3 测试规范

- 所有新增接口必须编写单元测试
- 前后端联调必须通过
- 边界情况必须测试（空数据、异常数据等）

## 7. 性能规范

### 7.1 查询性能

- 时间范围查询必须使用索引
- 大数据量查询必须分页
- 统计查询必须使用聚合函数

### 7.2 响应时间要求

- 简单查询：< 500ms
- 统计查询：< 2s
- 复杂分析：< 5s

## 8. 安全规范

### 8.1 权限控制

- 所有接口必须添加 `@LoginRequired` 注解
- 敏感操作必须添加 `@GroupRequired` 注解
- 权限验证必须通过 `@PermissionMeta` 注解

### 8.2 数据验证

- 所有输入参数必须验证
- 时间范围必须验证合理性
- ID参数必须验证存在性

## 9. 文档规范

### 9.1 API文档

- 使用 Swagger 注解生成API文档
- 所有接口必须有清晰的说明
- 参数和返回值必须有示例

### 9.2 代码注释

- 复杂逻辑必须有注释
- 公共方法必须有JavaDoc
- 业务规则必须有说明

## 10. 版本兼容性

### 10.1 向后兼容

- 新增字段使用可选参数
- 废弃字段保留但标记为 `@Deprecated`
- API版本使用路径区分（`/v1/`, `/v2/`）

### 10.2 迁移策略

- 重大变更必须提供迁移文档
- 数据格式变更必须提供转换工具
- 接口变更必须提前通知

---

**最后更新**: 2024-11-19
**维护者**: Easy JMeter Team

